{"name": "test_Tripartite_interaction", "status": "broken", "statusDetails": {"message": "requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\", ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None))", "trace": "self = <urllib3.response.HTTPResponse object at 0x0000022BAB9F2908>\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n>               yield\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000022BAB9F2908>, amt = 10240\ndecode_content = True, cache_content = False\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n    \n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n    \n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n    \n        if self._fp is None:\n            return\n    \n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n>               data = self._fp.read(amt) if not fp_closed else b\"\"\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:518: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <http.client.HTTPResponse object at 0x0000022BAB9F2DA0>, amt = 10240\n\n    def read(self, amt=None):\n        if self.fp is None:\n            return b\"\"\n    \n        if self._method == \"HEAD\":\n            self._close_conn()\n            return b\"\"\n    \n        if amt is not None:\n            # Amount is given, implement using readinto\n            b = bytearray(amt)\n>           n = self.readinto(b)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\http\\client.py:449: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <http.client.HTTPResponse object at 0x0000022BAB9F2DA0>\nb = bytearray(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x...0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into bytearray b and return the number\n        of bytes read.\n        \"\"\"\n    \n        if self.fp is None:\n            return 0\n    \n        if self._method == \"HEAD\":\n            self._close_conn()\n            return 0\n    \n        if self.chunked:\n            return self._readinto_chunked(b)\n    \n        if self.length is not None:\n            if len(b) > self.length:\n                # clip the read to the \"end of response\"\n                b = memoryview(b)[0:self.length]\n    \n        # we do not use _safe_read() here because this may be a .will_close\n        # connection, and the user is reading more bytes than will be provided\n        # (for example, reading in 1k chunks)\n>       n = self.fp.readinto(b)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\http\\client.py:493: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <socket.SocketIO object at 0x0000022BAB9F2EF0>\nb = <memory at 0x0000022BAB96FC48>\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into the writable buffer *b* and return\n        the number of bytes read.  If the socket is non-blocking and no bytes\n        are available, None is returned.\n    \n        If *b* is non-empty, a 0 return value indicates that the connection\n        was shutdown at the other end.\n        \"\"\"\n        self._checkClosed()\n        self._checkReadable()\n        if self._timeout_occurred:\n            raise OSError(\"cannot read from timed out object\")\n        while True:\n            try:\n>               return self._sock.recv_into(b)\nE               ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\socket.py:586: ConnectionResetError\n\nDuring handling of the above exception, another exception occurred:\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, 'stream'):\n            try:\n>               for chunk in self.raw.stream(chunk_size, decode_content=True):\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\models.py:751: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000022BAB9F2908>, amt = 10240\ndecode_content = True\n\n    def stream(self, amt=2 ** 16, decode_content=None):\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n    \n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if self.chunked and self.supports_chunked_reads():\n            for line in self.read_chunked(amt, decode_content=decode_content):\n                yield line\n        else:\n            while not is_fp_closed(self._fp):\n>               data = self.read(amt=amt, decode_content=decode_content)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:575: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000022BAB9F2908>, amt = 10240\ndecode_content = True, cache_content = False\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n    \n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n    \n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n    \n        if self._fp is None:\n            return\n    \n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n                data = self._fp.read(amt) if not fp_closed else b\"\"\n                if (\n                    amt != 0 and not data\n                ):  # Platform-specific: Buggy versions of Python.\n                    # Close the connection when no data is returned\n                    #\n                    # This is redundant to what httplib/http.client _should_\n                    # already do.  However, versions of python released before\n                    # December 15, 2012 (http://bugs.python.org/issue16298) do\n                    # not properly close the connection in all cases. There is\n                    # no harm in redundantly calling close.\n                    self._fp.close()\n                    flush_decoder = True\n                    if self.enforce_content_length and self.length_remaining not in (\n                        0,\n                        None,\n                    ):\n                        # This is an edge case that httplib failed to cover due\n                        # to concerns of backward compatibility. We're\n                        # addressing it here to make sure IncompleteRead is\n                        # raised during streaming, so all calls with incorrect\n                        # Content-Length are caught.\n>                       raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:540: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <contextlib._GeneratorContextManager object at 0x0000022BAB9FB278>\ntype = <class 'ConnectionResetError'>\nvalue = ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\ntraceback = <traceback object at 0x0000022BAB9F3DC8>\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = type()\n            try:\n>               self.gen.throw(type, value, traceback)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\contextlib.py:99: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000022BAB9F2908>\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n                yield\n    \n            except SocketTimeout:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n    \n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):  # Defensive:\n                    # This shouldn't happen but just in case we're missing an edge\n                    # case, let's avoid swallowing SSL errors.\n                    raise\n    \n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n    \n            except (HTTPException, SocketError) as e:\n                # This includes IncompleteRead.\n>               raise ProtocolError(\"Connection broken: %r\" % e, e)\nE               urllib3.exceptions.ProtocolError: (\"Connection broken: ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\", ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None))\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:454: ProtocolError\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.mark.run(order=-1)\n    @allure.severity(\"blocker\")\n    @allure.description(\"测试 http://10.10.128.152:10052/#/account/login 三方（企业，银行，前端）交互\")\n    @allure.testcase(\"http://10.10.128.152:10052/#/account/login\", \"三方（企业，银行，前端）交互 👇\")\n    def test_Tripartite_interaction():\n        def_name = sys._getframe().f_code.co_name\n        logger.info(\"开始执行脚本%s:\\n\", def_name)\n    \n        # 前端账户授信申请\n        if runMode == 'UI':\n            driver_forward = webdriver.Chrome()\n            driver_forward.maximize_window()\n            driver_forward.get(url_forward)\n            logger.info('前端账户登录授信申请')\n            login(driver_forward)\n            sleep(2)\n            # creditExtension(driver_forward)\n        else:\n            waiteForClick(mobileDriver(text='首页'))\n            waiteForClick(mobileDriver(text='立即申请'))\n            el = mobileDriver(text='首页', name='android.view.View', type='android.view.View')\n            dragUntilTextAppear(el, '产品服务', product_name)\n            waiteForClick(mobileDriver(text=product_name))\n            waiteForClick(mobileDriver(text='立即申请'))\n    \n            logger.info('授信采购信息画面')\n            waiteForClick(mobileDriver(text='请输入银行账号'))\n            text('123456789012')\n            mobileDriver(text='分支行').click()\n            waiteForClick(mobileDriver(text='请选择项目'))\n            waiteForClick(mobileDriver(text='请输入项目名称').parent().parent().parent().child()[2])\n            waiteForClick(mobileDriver(text='下一步'))\n    \n            logger.info('授信基本资料页面')\n            waiteForClick(mobileDriver(text='下一步'))\n    \n            logger.info('授信页面')\n            mobileDriver(text='企业经营场所照片').drag_to(mobileDriver(text='业务申请'), 0.5)\n            mobileDriver(text='企业征信').drag_to(mobileDriver(text='业务申请'), 0.5)\n            mobileDriver(text='财务证明资料').drag_to(mobileDriver(text='业务申请'), 0.5)\n            waiteForClick(mobileDriver(text='我已阅读并同意提交资料', type='android.widget.CheckBox').child().child())\n            waiteForClick(mobileDriver(text='提交授信'))\n            # 活体认证欺诈性校验\n            getVerification()\n            waiteForClick(mobileDriver(name='com.tencent.mm:id/dc'))\n            waiteForClick(mobileDriver(name='com.tencent.mm:id/dc'))\n            logger.info('授信完成页面')\n    \n        # 银行授信审核\n        driver_bank = webdriver.Chrome()\n        driver_bank.maximize_window()\n        driver_bank.get(url_back)\n        logger.info('银行授信审核')\n        backStageLogin(driver_bank, company_bank, company_bank_pass, 0)\n        CreditAudit_Bank(driver_bank)\n    \n        # 担保公司审核\n        driver_risk = webdriver.Chrome()\n        driver_risk.maximize_window()\n        driver_risk.get(url_back)\n        logger.info('担保公司审核')\n        backStageLogin(driver_risk, company_Guarantee, company_Guarantee_pass, 0)\n        CreditAudit_Risk(driver_risk)\n    \n        # 借款申请\n        if runMode == 'UI':\n>           loanApply(driver_forward)\n\ntest_flow\\test_Tripartite_interaction\\test_Tripartite_interaction.py:203: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntest_flow\\test_Tripartite_interaction\\test_Tripartite_interaction.py:459: in loanApply\n    r = getVerification()\ncommon\\dbLink.py:239: in getVerification\n    \"Dgtlenvlp\": \"MvXuUCz6PVUBb7xJhkJ6eU8QmPrgNL3lSgt5XQRiAsjdbeoQf3WapDlmHKIgr9Kj9wJFCw6ovl+5xd77xAtWynr8Xl+puaihAFhXN05DWEvBBv5Qjhm7gmzFdf1davKM/DMMWParIVusIDWJvKTyviSIuUsnIA50RFBuHcSC9KWXLioLEQht1L4BFR3F1M0/pFDnT2///VjM3PsvT/iFlDB82pXL4y+AA7EADE5aD5PrLG6ah57iNOrQUeJBmf8FCXXG8JoU/W/a3KqgOG0DwCi0fgSFWC7XuJXrTCJZBROi7LvLnWkvRaKk9LOHseUGAyuUJUENi5C3TbztDRfXSg==\"}, )\ncommon\\Request.py:33: in post_Req\n    res = requests.post(url, data=data, json=json, **kw)  # 其中data是form表单形式的\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\api.py:119: in post\n    return request('post', url, data=data, json=json, **kwargs)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\api.py:61: in request\n    return session.request(method=method, url=url, **kwargs)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\sessions.py:530: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\sessions.py:685: in send\n    r.content\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\models.py:829: in content\n    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, 'stream'):\n            try:\n                for chunk in self.raw.stream(chunk_size, decode_content=True):\n                    yield chunk\n            except ProtocolError as e:\n>               raise ChunkedEncodingError(e)\nE               requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\", ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None))\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\models.py:754: ChunkedEncodingError"}, "description": "测试 http://10.10.128.152:10052/#/account/login 三方（企业，银行，前端）交互", "attachments": [{"name": "log", "source": "d2caaab2-88a2-45f5-b2f8-67285d4d3472-attachment.txt", "type": "text/plain"}, {"name": "stdout", "source": "d560e994-a48b-4b5f-a4b2-b5a905796f98-attachment.txt", "type": "text/plain"}, {"name": "stderr", "source": "54d317c6-cb9f-45e1-8041-0e12e276f9bd-attachment.txt", "type": "text/plain"}], "start": 1603431643896, "stop": 1603431707484, "uuid": "1886ef8e-d8a2-43d1-acce-3a6910174faa", "historyId": "d91e7b4392163e0b46289a9f8b97b16c", "testCaseId": "ff94b3cb02e8ba4f94c9f712dc0dd88c", "fullName": "test_flow.test_Tripartite_interaction.test_Tripartite_interaction#test_Tripartite_interaction", "labels": [{"name": "severity", "value": "blocker"}, {"name": "tag", "value": "run(order=-1)"}, {"name": "parentSuite", "value": "test_flow.test_Tripartite_interaction"}, {"name": "suite", "value": "test_Tripartite_interaction"}, {"name": "host", "value": "A02-03-00033"}, {"name": "thread", "value": "12256-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_flow.test_Tripartite_interaction.test_Tripartite_interaction"}], "links": [{"type": "test_case", "url": "http://10.10.128.152:10052/#/account/login", "name": "三方（企业，银行，前端）交互 👇"}]}