{
  "uid" : "20104e724c9fcb00",
  "name" : "test_companyRegister",
  "fullName" : "test_flow.test_Authentication.test_login#test_companyRegister",
  "historyId" : "dd0646a5c1a798e47c4f25747509dea9",
  "time" : {
    "start" : 1602838889112,
    "stop" : 1602838937815,
    "duration" : 48703
  },
  "description" : "测试 http://10.10.128.152:10053/user/register 中小微企业注册流程",
  "descriptionHtml" : "<p>测试 http://10.10.128.152:10053/user/register 中小微企业注册流程</p>\n",
  "status" : "broken",
  "statusMessage" : "requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\", ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None))",
  "statusTrace" : "self = <urllib3.response.HTTPResponse object at 0x0000021C884C8BE0>\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n>               yield\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000021C884C8BE0>, amt = 10240\ndecode_content = True, cache_content = False\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n    \n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n    \n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n    \n        if self._fp is None:\n            return\n    \n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n>               data = self._fp.read(amt) if not fp_closed else b\"\"\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:518: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <http.client.HTTPResponse object at 0x0000021C884C8588>, amt = 10240\n\n    def read(self, amt=None):\n        if self.fp is None:\n            return b\"\"\n    \n        if self._method == \"HEAD\":\n            self._close_conn()\n            return b\"\"\n    \n        if amt is not None:\n            # Amount is given, implement using readinto\n            b = bytearray(amt)\n>           n = self.readinto(b)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\http\\client.py:449: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <http.client.HTTPResponse object at 0x0000021C884C8588>\nb = bytearray(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x...0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into bytearray b and return the number\n        of bytes read.\n        \"\"\"\n    \n        if self.fp is None:\n            return 0\n    \n        if self._method == \"HEAD\":\n            self._close_conn()\n            return 0\n    \n        if self.chunked:\n            return self._readinto_chunked(b)\n    \n        if self.length is not None:\n            if len(b) > self.length:\n                # clip the read to the \"end of response\"\n                b = memoryview(b)[0:self.length]\n    \n        # we do not use _safe_read() here because this may be a .will_close\n        # connection, and the user is reading more bytes than will be provided\n        # (for example, reading in 1k chunks)\n>       n = self.fp.readinto(b)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\http\\client.py:493: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <socket.SocketIO object at 0x0000021C884C84A8>\nb = <memory at 0x0000021C8845A048>\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into the writable buffer *b* and return\n        the number of bytes read.  If the socket is non-blocking and no bytes\n        are available, None is returned.\n    \n        If *b* is non-empty, a 0 return value indicates that the connection\n        was shutdown at the other end.\n        \"\"\"\n        self._checkClosed()\n        self._checkReadable()\n        if self._timeout_occurred:\n            raise OSError(\"cannot read from timed out object\")\n        while True:\n            try:\n>               return self._sock.recv_into(b)\nE               ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\socket.py:586: ConnectionResetError\n\nDuring handling of the above exception, another exception occurred:\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, 'stream'):\n            try:\n>               for chunk in self.raw.stream(chunk_size, decode_content=True):\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\models.py:751: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000021C884C8BE0>, amt = 10240\ndecode_content = True\n\n    def stream(self, amt=2 ** 16, decode_content=None):\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n    \n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if self.chunked and self.supports_chunked_reads():\n            for line in self.read_chunked(amt, decode_content=decode_content):\n                yield line\n        else:\n            while not is_fp_closed(self._fp):\n>               data = self.read(amt=amt, decode_content=decode_content)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:575: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000021C884C8BE0>, amt = 10240\ndecode_content = True, cache_content = False\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n    \n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n    \n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n    \n        if self._fp is None:\n            return\n    \n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n                data = self._fp.read(amt) if not fp_closed else b\"\"\n                if (\n                    amt != 0 and not data\n                ):  # Platform-specific: Buggy versions of Python.\n                    # Close the connection when no data is returned\n                    #\n                    # This is redundant to what httplib/http.client _should_\n                    # already do.  However, versions of python released before\n                    # December 15, 2012 (http://bugs.python.org/issue16298) do\n                    # not properly close the connection in all cases. There is\n                    # no harm in redundantly calling close.\n                    self._fp.close()\n                    flush_decoder = True\n                    if self.enforce_content_length and self.length_remaining not in (\n                        0,\n                        None,\n                    ):\n                        # This is an edge case that httplib failed to cover due\n                        # to concerns of backward compatibility. We're\n                        # addressing it here to make sure IncompleteRead is\n                        # raised during streaming, so all calls with incorrect\n                        # Content-Length are caught.\n>                       raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:540: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <contextlib._GeneratorContextManager object at 0x0000021C884C8CC0>\ntype = <class 'ConnectionResetError'>\nvalue = ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\ntraceback = <traceback object at 0x0000021C884B2988>\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = type()\n            try:\n>               self.gen.throw(type, value, traceback)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\contextlib.py:99: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000021C884C8BE0>\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n                yield\n    \n            except SocketTimeout:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n    \n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):  # Defensive:\n                    # This shouldn't happen but just in case we're missing an edge\n                    # case, let's avoid swallowing SSL errors.\n                    raise\n    \n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n    \n            except (HTTPException, SocketError) as e:\n                # This includes IncompleteRead.\n>               raise ProtocolError(\"Connection broken: %r\" % e, e)\nE               urllib3.exceptions.ProtocolError: (\"Connection broken: ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\", ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None))\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:454: ProtocolError\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.mark.run(order=1)\n    @allure.severity(\"blocker\")\n    @allure.description(\"测试 http://10.10.128.152:10053/user/register 中小微企业注册流程\")\n    @allure.testcase(\"http://10.10.128.152:10053/user/register\", \"注册 \uD83D\uDC47\")\n    def test_companyRegister():\n        if runMode == 'UI':\n            def_name = sys._getframe().f_code.co_name\n            test_Assert = Assert.Assertions(def_name)\n            logger.info(\"开始执行脚本%s:\\n\", def_name)\n    \n            driver = webdriver.Chrome()\n            driver.maximize_window()\n            driver.get(url_ui_register)\n            # db中清除已注册的账户\n            deleteInforMobile()\n            logger.info(\"对已注册的账户进行删除操作\")\n            sleep(1)\n            waitUntilClick(driver, loginOn.btn_agree_css.value)\n            driver.find_element_by_css_selector(loginOn.btn_agree_css.value).click()\n    \n            waitUntilDisplay(driver, loginOn.input_act_css.value)\n            driver.find_element_by_css_selector(loginOn.input_act_css.value).send_keys(act)\n            driver.find_element_by_css_selector(loginOn.input_pwd_css.value).send_keys(pwd)\n            driver.find_element_by_css_selector(loginOn.input_conPwd_css.value).send_keys(pwd)\n            waitUntilClick(driver, loginOn.btn_phoneCode_css.value)\n            sleep(2)\n            flushDb()\n            driver.find_element_by_css_selector(loginOn.btn_phoneCode_css.value).click()\n    \n            while 1:\n                message = getPhoneMessage().get(\"regMes\")\n                if message is None:\n                    sleep(0.5)\n                    continue\n                else:\n                    break\n    \n            driver.find_element_by_css_selector(loginOn.input_phoneCode_css.value).send_keys(message.strip().strip('\"'))\n            waitUntilClick(driver, loginOn.btn_agreeReg.value)\n            driver.find_element_by_css_selector(loginOn.btn_agreeReg.value).click()\n    \n            title = driver.title\n            test_Assert.assert_text_ui(title, '中小微企业金融服务聚合平台')\n            logger.info(\"注册成功，返回到登陆页面\")\n            sleep(1)\n            driver.quit()\n        else:\n            # touch(Template(r\"C:\\Users\\shaojunshuai\\PycharmProjects\\AutoTest-python\\Auto_Test\\test_data\\picture\\id_5.png\"))\n            startWeinxin()\n            deleteInforMobile()  # 删除个人信息\n            # clearCache()\n            mobileDriver(text='一键微信授权登录').click()\n            waiteForClick(mobileDriver(text='允许'))\n            waiteForClick(mobileDriver(text='授权手机号'))\n            waiteForClick(mobileDriver(text='允许'))\n    \n            logger.info(\"PC 端进行密码修改\")\n            # companyPassForgetForward(act)\n            logger.info(\"小程序个人实名认证页面\")\n    \n            # 上传身份证正反面\n            waiteForClick(mobileDriver(text='请上传身份证头像面'))\n            waiteForClick(mobileDriver(text='所有图片'))\n            waiteForClick(mobileDriver(text='自动化测试专用相册'))\n            mobileDriver(\"android.widget.LinearLayout\").offspring(\"com.tencent.mm:id/dm6\").child(\"com.tencent.mm:id/f4b\")[\n                3].child(\n                \"com.tencent.mm:id/dm0\").click()\n            waiteForClick(mobileDriver(text='完成'))\n            sleep(2)\n            waiteForClick(mobileDriver(text='请上传身份证国徽面'))\n            waiteForClick(mobileDriver(text='所有图片'))\n            waiteForClick(mobileDriver(text='自动化测试专用相册'))\n            mobileDriver(\"android.widget.LinearLayout\").offspring(\"com.tencent.mm:id/dm6\").child(\"com.tencent.mm:id/f4b\")[\n                2].child(\n                \"com.tencent.mm:id/dm8\").click()\n            waiteForClick(mobileDriver(text='完成'))\n            sleep(1)\n            waiteForClick(mobileDriver(text='提交认证'))\n            # 活体认证欺诈性校验\n>           getVerification()\n\ntest_flow\\test_Authentication\\test_login.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ncommon\\dbLink.py:239: in getVerification\n    \"Dgtlenvlp\": \"MvXuUCz6PVUBb7xJhkJ6eU8QmPrgNL3lSgt5XQRiAsjdbeoQf3WapDlmHKIgr9Kj9wJFCw6ovl+5xd77xAtWynr8Xl+puaihAFhXN05DWEvBBv5Qjhm7gmzFdf1davKM/DMMWParIVusIDWJvKTyviSIuUsnIA50RFBuHcSC9KWXLioLEQht1L4BFR3F1M0/pFDnT2///VjM3PsvT/iFlDB82pXL4y+AA7EADE5aD5PrLG6ah57iNOrQUeJBmf8FCXXG8JoU/W/a3KqgOG0DwCi0fgSFWC7XuJXrTCJZBROi7LvLnWkvRaKk9LOHseUGAyuUJUENi5C3TbztDRfXSg==\"}, )\ncommon\\Request.py:33: in post_Req\n    res = requests.post(url, data=data, json=json, **kw)  # 其中data是form表单形式的\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\api.py:119: in post\n    return request('post', url, data=data, json=json, **kwargs)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\api.py:61: in request\n    return session.request(method=method, url=url, **kwargs)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\sessions.py:530: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\sessions.py:685: in send\n    r.content\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\models.py:829: in content\n    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, 'stream'):\n            try:\n                for chunk in self.raw.stream(chunk_size, decode_content=True):\n                    yield chunk\n            except ProtocolError as e:\n>               raise ChunkedEncodingError(e)\nE               requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\", ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None))\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\models.py:754: ChunkedEncodingError",
  "flaky" : false,
  "newFailed" : false,
  "beforeStages" : [ ],
  "testStage" : {
    "description" : "测试 http://10.10.128.152:10053/user/register 中小微企业注册流程",
    "status" : "broken",
    "statusMessage" : "requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\", ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None))",
    "statusTrace" : "self = <urllib3.response.HTTPResponse object at 0x0000021C884C8BE0>\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n>               yield\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000021C884C8BE0>, amt = 10240\ndecode_content = True, cache_content = False\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n    \n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n    \n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n    \n        if self._fp is None:\n            return\n    \n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n>               data = self._fp.read(amt) if not fp_closed else b\"\"\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:518: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <http.client.HTTPResponse object at 0x0000021C884C8588>, amt = 10240\n\n    def read(self, amt=None):\n        if self.fp is None:\n            return b\"\"\n    \n        if self._method == \"HEAD\":\n            self._close_conn()\n            return b\"\"\n    \n        if amt is not None:\n            # Amount is given, implement using readinto\n            b = bytearray(amt)\n>           n = self.readinto(b)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\http\\client.py:449: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <http.client.HTTPResponse object at 0x0000021C884C8588>\nb = bytearray(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x...0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into bytearray b and return the number\n        of bytes read.\n        \"\"\"\n    \n        if self.fp is None:\n            return 0\n    \n        if self._method == \"HEAD\":\n            self._close_conn()\n            return 0\n    \n        if self.chunked:\n            return self._readinto_chunked(b)\n    \n        if self.length is not None:\n            if len(b) > self.length:\n                # clip the read to the \"end of response\"\n                b = memoryview(b)[0:self.length]\n    \n        # we do not use _safe_read() here because this may be a .will_close\n        # connection, and the user is reading more bytes than will be provided\n        # (for example, reading in 1k chunks)\n>       n = self.fp.readinto(b)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\http\\client.py:493: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <socket.SocketIO object at 0x0000021C884C84A8>\nb = <memory at 0x0000021C8845A048>\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into the writable buffer *b* and return\n        the number of bytes read.  If the socket is non-blocking and no bytes\n        are available, None is returned.\n    \n        If *b* is non-empty, a 0 return value indicates that the connection\n        was shutdown at the other end.\n        \"\"\"\n        self._checkClosed()\n        self._checkReadable()\n        if self._timeout_occurred:\n            raise OSError(\"cannot read from timed out object\")\n        while True:\n            try:\n>               return self._sock.recv_into(b)\nE               ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\socket.py:586: ConnectionResetError\n\nDuring handling of the above exception, another exception occurred:\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, 'stream'):\n            try:\n>               for chunk in self.raw.stream(chunk_size, decode_content=True):\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\models.py:751: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000021C884C8BE0>, amt = 10240\ndecode_content = True\n\n    def stream(self, amt=2 ** 16, decode_content=None):\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n    \n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if self.chunked and self.supports_chunked_reads():\n            for line in self.read_chunked(amt, decode_content=decode_content):\n                yield line\n        else:\n            while not is_fp_closed(self._fp):\n>               data = self.read(amt=amt, decode_content=decode_content)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:575: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000021C884C8BE0>, amt = 10240\ndecode_content = True, cache_content = False\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n    \n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n    \n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n    \n        if self._fp is None:\n            return\n    \n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n                data = self._fp.read(amt) if not fp_closed else b\"\"\n                if (\n                    amt != 0 and not data\n                ):  # Platform-specific: Buggy versions of Python.\n                    # Close the connection when no data is returned\n                    #\n                    # This is redundant to what httplib/http.client _should_\n                    # already do.  However, versions of python released before\n                    # December 15, 2012 (http://bugs.python.org/issue16298) do\n                    # not properly close the connection in all cases. There is\n                    # no harm in redundantly calling close.\n                    self._fp.close()\n                    flush_decoder = True\n                    if self.enforce_content_length and self.length_remaining not in (\n                        0,\n                        None,\n                    ):\n                        # This is an edge case that httplib failed to cover due\n                        # to concerns of backward compatibility. We're\n                        # addressing it here to make sure IncompleteRead is\n                        # raised during streaming, so all calls with incorrect\n                        # Content-Length are caught.\n>                       raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:540: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <contextlib._GeneratorContextManager object at 0x0000021C884C8CC0>\ntype = <class 'ConnectionResetError'>\nvalue = ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\ntraceback = <traceback object at 0x0000021C884B2988>\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = type()\n            try:\n>               self.gen.throw(type, value, traceback)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\contextlib.py:99: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x0000021C884C8BE0>\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n                yield\n    \n            except SocketTimeout:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n    \n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):  # Defensive:\n                    # This shouldn't happen but just in case we're missing an edge\n                    # case, let's avoid swallowing SSL errors.\n                    raise\n    \n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n    \n            except (HTTPException, SocketError) as e:\n                # This includes IncompleteRead.\n>               raise ProtocolError(\"Connection broken: %r\" % e, e)\nE               urllib3.exceptions.ProtocolError: (\"Connection broken: ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\", ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None))\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\urllib3\\response.py:454: ProtocolError\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.mark.run(order=1)\n    @allure.severity(\"blocker\")\n    @allure.description(\"测试 http://10.10.128.152:10053/user/register 中小微企业注册流程\")\n    @allure.testcase(\"http://10.10.128.152:10053/user/register\", \"注册 \uD83D\uDC47\")\n    def test_companyRegister():\n        if runMode == 'UI':\n            def_name = sys._getframe().f_code.co_name\n            test_Assert = Assert.Assertions(def_name)\n            logger.info(\"开始执行脚本%s:\\n\", def_name)\n    \n            driver = webdriver.Chrome()\n            driver.maximize_window()\n            driver.get(url_ui_register)\n            # db中清除已注册的账户\n            deleteInforMobile()\n            logger.info(\"对已注册的账户进行删除操作\")\n            sleep(1)\n            waitUntilClick(driver, loginOn.btn_agree_css.value)\n            driver.find_element_by_css_selector(loginOn.btn_agree_css.value).click()\n    \n            waitUntilDisplay(driver, loginOn.input_act_css.value)\n            driver.find_element_by_css_selector(loginOn.input_act_css.value).send_keys(act)\n            driver.find_element_by_css_selector(loginOn.input_pwd_css.value).send_keys(pwd)\n            driver.find_element_by_css_selector(loginOn.input_conPwd_css.value).send_keys(pwd)\n            waitUntilClick(driver, loginOn.btn_phoneCode_css.value)\n            sleep(2)\n            flushDb()\n            driver.find_element_by_css_selector(loginOn.btn_phoneCode_css.value).click()\n    \n            while 1:\n                message = getPhoneMessage().get(\"regMes\")\n                if message is None:\n                    sleep(0.5)\n                    continue\n                else:\n                    break\n    \n            driver.find_element_by_css_selector(loginOn.input_phoneCode_css.value).send_keys(message.strip().strip('\"'))\n            waitUntilClick(driver, loginOn.btn_agreeReg.value)\n            driver.find_element_by_css_selector(loginOn.btn_agreeReg.value).click()\n    \n            title = driver.title\n            test_Assert.assert_text_ui(title, '中小微企业金融服务聚合平台')\n            logger.info(\"注册成功，返回到登陆页面\")\n            sleep(1)\n            driver.quit()\n        else:\n            # touch(Template(r\"C:\\Users\\shaojunshuai\\PycharmProjects\\AutoTest-python\\Auto_Test\\test_data\\picture\\id_5.png\"))\n            startWeinxin()\n            deleteInforMobile()  # 删除个人信息\n            # clearCache()\n            mobileDriver(text='一键微信授权登录').click()\n            waiteForClick(mobileDriver(text='允许'))\n            waiteForClick(mobileDriver(text='授权手机号'))\n            waiteForClick(mobileDriver(text='允许'))\n    \n            logger.info(\"PC 端进行密码修改\")\n            # companyPassForgetForward(act)\n            logger.info(\"小程序个人实名认证页面\")\n    \n            # 上传身份证正反面\n            waiteForClick(mobileDriver(text='请上传身份证头像面'))\n            waiteForClick(mobileDriver(text='所有图片'))\n            waiteForClick(mobileDriver(text='自动化测试专用相册'))\n            mobileDriver(\"android.widget.LinearLayout\").offspring(\"com.tencent.mm:id/dm6\").child(\"com.tencent.mm:id/f4b\")[\n                3].child(\n                \"com.tencent.mm:id/dm0\").click()\n            waiteForClick(mobileDriver(text='完成'))\n            sleep(2)\n            waiteForClick(mobileDriver(text='请上传身份证国徽面'))\n            waiteForClick(mobileDriver(text='所有图片'))\n            waiteForClick(mobileDriver(text='自动化测试专用相册'))\n            mobileDriver(\"android.widget.LinearLayout\").offspring(\"com.tencent.mm:id/dm6\").child(\"com.tencent.mm:id/f4b\")[\n                2].child(\n                \"com.tencent.mm:id/dm8\").click()\n            waiteForClick(mobileDriver(text='完成'))\n            sleep(1)\n            waiteForClick(mobileDriver(text='提交认证'))\n            # 活体认证欺诈性校验\n>           getVerification()\n\ntest_flow\\test_Authentication\\test_login.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ncommon\\dbLink.py:239: in getVerification\n    \"Dgtlenvlp\": \"MvXuUCz6PVUBb7xJhkJ6eU8QmPrgNL3lSgt5XQRiAsjdbeoQf3WapDlmHKIgr9Kj9wJFCw6ovl+5xd77xAtWynr8Xl+puaihAFhXN05DWEvBBv5Qjhm7gmzFdf1davKM/DMMWParIVusIDWJvKTyviSIuUsnIA50RFBuHcSC9KWXLioLEQht1L4BFR3F1M0/pFDnT2///VjM3PsvT/iFlDB82pXL4y+AA7EADE5aD5PrLG6ah57iNOrQUeJBmf8FCXXG8JoU/W/a3KqgOG0DwCi0fgSFWC7XuJXrTCJZBROi7LvLnWkvRaKk9LOHseUGAyuUJUENi5C3TbztDRfXSg==\"}, )\ncommon\\Request.py:33: in post_Req\n    res = requests.post(url, data=data, json=json, **kw)  # 其中data是form表单形式的\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\api.py:119: in post\n    return request('post', url, data=data, json=json, **kwargs)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\api.py:61: in request\n    return session.request(method=method, url=url, **kwargs)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\sessions.py:530: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\sessions.py:685: in send\n    r.content\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\models.py:829: in content\n    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, 'stream'):\n            try:\n                for chunk in self.raw.stream(chunk_size, decode_content=True):\n                    yield chunk\n            except ProtocolError as e:\n>               raise ChunkedEncodingError(e)\nE               requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)\", ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None))\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\requests\\models.py:754: ChunkedEncodingError",
    "steps" : [ ],
    "attachments" : [ {
      "uid" : "efc8a37d7ae94484",
      "name" : "log",
      "source" : "efc8a37d7ae94484.txt",
      "type" : "text/plain",
      "size" : 4335
    }, {
      "uid" : "1a20888247e054b8",
      "name" : "stderr",
      "source" : "1a20888247e054b8.txt",
      "type" : "text/plain",
      "size" : 4409
    } ],
    "parameters" : [ ],
    "attachmentsCount" : 2,
    "shouldDisplayMessage" : true,
    "stepsCount" : 0,
    "hasContent" : true
  },
  "afterStages" : [ ],
  "labels" : [ {
    "name" : "severity",
    "value" : "blocker"
  }, {
    "name" : "tag",
    "value" : "run(order=1)"
  }, {
    "name" : "parentSuite",
    "value" : "test_flow.test_Authentication"
  }, {
    "name" : "suite",
    "value" : "test_login"
  }, {
    "name" : "host",
    "value" : "A02-03-00033"
  }, {
    "name" : "thread",
    "value" : "4676-MainThread"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "package",
    "value" : "test_flow.test_Authentication.test_login"
  }, {
    "name" : "resultFormat",
    "value" : "allure2"
  } ],
  "parameters" : [ ],
  "links" : [ {
    "name" : "注册 \uD83D\uDC47",
    "url" : "http://10.10.128.152:10053/user/register",
    "type" : "test_case"
  } ],
  "hidden" : true,
  "retry" : true,
  "extra" : {
    "categories" : [ ],
    "tags" : [ "run(order=1)" ]
  },
  "source" : "20104e724c9fcb00.json",
  "parameterValues" : [ ]
}